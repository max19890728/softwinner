/*****************************************************************************
 Copyright (C), 2015, AllwinnerTech. Co., Ltd.
 File name: application.cpp
 Author: yangy@allwinnertech.com
 Version: v1.0
 Date: 2015-11-24
 Description:
    Application will be created when cited for the first time.
    The uniqueness of the global instance is guaranteed.
 History:
*****************************************************************************/

#include "application.h"
#include "window/window.h"
#include "debug/app_log.h"

#include <vo/hwdisplay.h>

#include <thread>

using namespace std;

/* @variable */
#define UI_BASE_PATH "/usr/share/minigui/res/layout/"

#undef LOG_TAG
#define LOG_TAG "Application"

Application* Application::instance_ = NULL;
pthread_mutex_t Application::mutex_ = PTHREAD_MUTEX_INITIALIZER;

/* mutex is initialized here */
AppObject g_app_object;

Application::Application()
    : handle_(HWND_NULL), current_form_(NULL)
    , is_running_(false)
{
    CreateHandle();
    ui_path_ = UI_BASE_PATH;
}

Application::~Application()
{
    ::MainWindowThreadCleanup(GetHandle());
}

/*****************************************************************************
 Function: Application::HandleMessage
 Description: application handles some messages concerned
 Parameter:
 Return:
    result is generated by the system
*****************************************************************************/
int Application::HandleMessage(HWND hwnd, int message, WPARAM wparam,
                                        LPARAM lparam)
{
    if (message == MSG_KEYDOWN || message == MSG_KEYUP || message == MSG_CHAR)
    {
        if( g_app_object.OnKeyPress )
            return g_app_object.OnKeyPress(this, (DWORD)wparam);
    }
    return (DefaultMainWinProc(GetHandle(), message, wparam, lparam));
}

/*****************************************************************************
 Function: Application::WindowProc
 Description:
    dispatch the messages to the current form
 Parameter:
    #hwindow - the desktop in general
 Return:
    result is generated by the system
*****************************************************************************/
int Application::WindowProc(HWND hwindow, int message, WPARAM wparam,
                                    LPARAM lparam)
{
    return (DefaultMainWinProc(hwindow, message, wparam, lparam));
#if 0
    Application* app = NULL;//Application::instance_;
    _log_d("`app %p", app);
    if (message == MSG_NCCREATE) {
        _log_d("1 app %p", app);
        app = reinterpret_cast<Application*>(
                ((PMAINWINCREATE)lparam)->dwAddData);
        ::SetWindowAdditionalData2( hwindow, (DWORD)app);
    } else {
        app = reinterpret_cast<Application*>(
                ::GetWindowAdditionalData2(hwindow));
    }
    if (app) {
        if (app->current_form_) {
            int ret =  app->current_form_->HandleMessage(
                    app->current_form_->GetHandle(), message, wparam, lparam);
            _log_d("current_form ret:%d", ret);
            return ret;
            }
        else
            return app->HandleMessage(hwindow, message, wparam, lparam);
    } else {
        return (DefaultMainWinProc( hwindow, message, wparam, lparam));
    }
#endif
}


/*****************************************************************************
 Function: Application::CreateHandle
 Description: create the vacuous window
 Parameter: -
 Return: -
*****************************************************************************/
void Application::CreateHandle()
{
    MAINWINCREATE wc;
    wc.dwReserved     = 0;
    wc.dwStyle        = WS_NONE;
    wc.dwExStyle      = WS_EX_NONE;
    wc.spCaption      = "Application";
    wc.hMenu          = 0;
    wc.hCursor        = 0;
    wc.hIcon          = 0;
    wc.MainWindowProc = WindowProc;
    wc.lx             = 0;
    wc.ty             = 0;
    wc.rx             = 0;
    wc.by             = 0;
    wc.iBkColor       = 0;
    wc.dwAddData      = (DWORD)(Application::instance_);
    wc.hHosting       =  HWND_DESKTOP;
    handle_ = ::CreateMainWindow(&wc);
}

void Application::DestroyHandle()
{
    ::DestroyMainWindow(GetHandle());
}

/*****************************************************************************
 Function: Application::GetHandle
 Description: get the vacuous window's handle
 Parameter: -
 Return: the handle
*****************************************************************************/
HWND Application::GetHandle()
{
    return  handle_;
}

/*****************************************************************************
 Function: Application::GetCurrentWindow
 Description: get the current modal window
 Parameter: -
 Return: the class pointer of the current modal window
*****************************************************************************/
Window* Application::GetCurrentWindow()
{
    return  current_form_;
}


/*****************************************************************************
 Function: Application::SetCurrentWindow
 Description: set the current modal window
 Parameter: the window's pointer
 Return: return the last window's pointer
*****************************************************************************/
Window* Application::SetCurrentWindow(Window* form)
{
    Window* old_form = current_form_;
    current_form_ = form;
    return  old_form;
}


/*****************************************************************************
 Function: Application::GetApp
 Description: create the application instance with singleton creation pattern
 Parameter: -
 Return: the unique instance pointer
*****************************************************************************/
Application* Application::GetApp()
{
    if ( Application::instance_ == NULL )
    {
        pthread_mutex_lock( &Application::mutex_ );
        if (Application::instance_ == NULL )
        {
            Application::instance_ = new Application();
        }
        pthread_mutex_unlock( &Application::mutex_ );
    }
    return Application::instance_;
}

/*****************************************************************************
 Function: Application::DeleteApp
 Description: delete the instance
 Parameter: -
 Return: -
*****************************************************************************/
void Application::DeleteApp()
{
    if ( Application::instance_ )
    {
        pthread_mutex_lock( &Application::mutex_ );
        if (Application::instance_ )
        {
            delete Application::instance_;
            Application::instance_ = NULL;
        }
        pthread_mutex_unlock( &Application::mutex_ );
    }
}

/*****************************************************************************
 Function: Application::InitApplication
 Description: initialize the mutex to guarantee the safety of instance creation
 Parameter: -
 Return: -
*****************************************************************************/
void Application::InitApplication()
{
    pthread_mutex_init( &Application::mutex_, NULL );
}

/*****************************************************************************
 Function: Application::UninitApplication
 Description: destroy the instance mutex
 Parameter:
 Return:
*****************************************************************************/
void Application::UninitApplication()
{
    pthread_mutex_destroy(&Application::mutex_);
}

/*****************************************************************************
 Function: Application::Run
 Description: it's a loop that message is in circulation to be processed.
                ::DispatchMessage will call Application::WindowProc
 Parameter: -
 Return: -
*****************************************************************************/
void Application::Run()
{
    MSG msg;

    while (::GetMessage(&msg, GetHandle()))
    {
        ::TranslateMessage(&msg);
        ::DispatchMessage(&msg);
        if (!is_running_) {
            is_running_ = true;
            if (callback_ != nullptr)
                std::thread(callback_).detach();
        }
    }
    is_running_ = false;
    /* the loop is break that means over */
    DestroyHandle();
    DeleteApp();
}

/*****************************************************************************
 Function: Application::Terminate
 Description: terminate the message loop actively
 Parameter: -
 Return: -
*****************************************************************************/
void Application::Terminate()
{
    HWND hwnd = GetHandle();
    ::PostQuitMessage( hwnd );
}

/*****************************************************************************
 Function: Application::GetAppUIPath
 Description: the parser will call it in order to gets xml files
 Parameter:
 Return:
*****************************************************************************/
string Application::GetAppUIPath()
{
    return ui_path_;
}

/*****************************************************************************
 Function: Application::SetAppUIPath
 Description: set the ui resource path dynamically
 Parameter: the new path
 Return: -
*****************************************************************************/
void Application::SetAppUIPath(string path)
{
    ui_path_ = path;
}

void Application::RegistCallback(std::function<void(void)> func)
{
    callback_ = func;
}
