/*******************************************************************************
 * Copyright (c), 2021, Ultracker Tech. All rights reserved.
 ******************************************************************************/

#include "Device/US363/Cmd/h264_header.h"

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <malloc.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <time.h>

#include "Device/US363/us363_para.h"
#include "Device/US363/Cmd/AletaS2_CMD_Struct.h"
#include "common/app_log.h"

#undef LOG_TAG
#define LOG_TAG "US363::H264Header"

FPGA_H264_SPS_PPS_Struct FPGA_H264_SPS_PPS;

void ue_linfo2(int value, int *len, int *info) {
	int i, nn;
	nn = (value + 1) / 2;
	for(i = 0; i < 16 && nn != 0; i++)
		nn /= 2;
	*len  = (2 * i) + 1;
	*info = value + 1 - (int)pow(2,i);
}

static unsigned get_NAL(char *cS_Buf, char *cT_Buf, unsigned *size, unsigned type) {
	unsigned len, len1, len2, unit_len;
	unsigned uP1 = cS_Buf[0] | (cS_Buf[1]<<8) | (cS_Buf[2]<<16) | (cS_Buf[3]<<24);

	unit_len = 4;

	len      = *size;
	len1     = swap4(uP1);
	len2     = swap4(len1);

	if(type == 1) {
		unit_len = 2;
		len2     = swap2(len1);
	}

	memcpy(cT_Buf + len, (char *)&len2, unit_len);
	len     += unit_len;

	memcpy(cT_Buf + len, cS_Buf + 4, len1);
	len     += len1;

	*size    = len;

	return (len1 + 4);
}

/*
 * width		Pic width/16  -1
 * height		Pic height/16 -1
 */
int MakeHeader(char *S_Buf, int width, int height) {
    int Bit_Size, ByP,BtP;
	char byte_buf;
    int i, val, len, suffix_len;
    unsigned mask;
    char D0[10] = {0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0x00, 0x1E, 0xF2, 0x80};		// SPS Len
    char D1[9]  = {0x00, 0x00, 0x00, 0x05, 0x68, 0xC9, 0x08, 0x38, 0x80};			// PPS Len

    memcpy(&S_Buf[0], &D0[0], 10);
    ByP      = 9;
    BtP      = 6;
    Bit_Size = (9 * 8) + 2;

    //------------------------------------------------width
    ue_linfo2(width, &len, &val);
    Bit_Size += len;

    suffix_len = len / 2;
    val = (1 << suffix_len) | (val &((1 << suffix_len) - 1));

    mask = 1 << (len - 1);
    byte_buf = *(S_Buf + ByP);
    byte_buf >>= BtP;
    for(i = 0; i < len; i++) {
    	byte_buf <<= 1;
		if(val & mask) byte_buf |= 1;
		BtP--;
		mask >>= 1;
		if(BtP == 0) {
			BtP	           = 8;
			*(S_Buf + ByP) = byte_buf;
			ByP++;
			byte_buf       = 0;
		}
    }
    byte_buf <<= BtP;
    *(S_Buf + ByP) = byte_buf;

    //------------------------------------------------height
    ue_linfo2(height, &len, &val);
    Bit_Size += len;

    suffix_len = len / 2;
    val = (1 << suffix_len) | (val &((1 << suffix_len) - 1));

    mask = 1 << (len - 1);
    byte_buf = *(S_Buf + ByP);
    byte_buf >>= BtP;
    for(i = 0; i < len; i++) {
    	byte_buf <<= 1;
		if(val & mask) byte_buf |= 1;
		BtP--;
		mask >>= 1;
		if(BtP == 0) {
	    	BtP	           = 8;
	    	*(S_Buf + ByP) = byte_buf;
	    	ByP++;
	    	byte_buf       = 0;
		}
    }
    byte_buf <<= BtP;
    *(S_Buf + ByP) = byte_buf;

    //------------------------------------------------
    val = 0x19;
    len = 5;
    Bit_Size += len;
    mask = 1 << (len - 1);
    byte_buf = *(S_Buf + ByP);
    byte_buf >>= BtP;
    for(i = 0; i < len; i++) {
    	byte_buf <<= 1;
		if(val & mask) byte_buf |= 1;
		BtP--;
		mask >>= 1;
		if(BtP == 0) {
	    	BtP	           = 8;
	    	*(S_Buf + ByP) = byte_buf;
	    	ByP++;
	    	byte_buf       = 0;
		}
    }
    byte_buf <<= BtP;
    *(S_Buf + ByP) = byte_buf;

    *(S_Buf + 3)   = ((Bit_Size + 7) / 8) - 4;

    memcpy(&S_Buf[(Bit_Size + 7) / 8], &D1[0], 9);
    Bit_Size += (9 * 8);

    return (Bit_Size + 7) / 8;
}

void Set_FPGA_H264_SPS_PPS(char *buf) {
	int sps_len, pps_len;
	char *tmp, *sps, *pps;

	tmp = buf;
	memset(&FPGA_H264_SPS_PPS, 0, sizeof(FPGA_H264_SPS_PPS) );

	tmp++;
	sps_len = *tmp;

	tmp++;
	sps = tmp;

	tmp += (sps_len+2);
	pps_len = *tmp;

	tmp++;
	pps = tmp;

	FPGA_H264_SPS_PPS.sps_len = sps_len;
	if(sps_len > 0 && sps_len < 16)
		memcpy(&FPGA_H264_SPS_PPS.sps[0], sps, sps_len);
	else
		db_error("Set_FPGA_H264_SPS_PPS() sps_len error!\n");
	FPGA_H264_SPS_PPS.pps_len = pps_len;
	if(pps_len > 0 && pps_len < 16)
		memcpy(&FPGA_H264_SPS_PPS.pps[0], pps, pps_len);
	else
		db_error("Set_FPGA_H264_SPS_PPS() pps_len error!\n");

	db_debug("Set_FPGA_H264_SPS_PPS() sps_len=%d sps[0]=0x%02x sps[1]=0x%02x  pps_len=%d pps[0]=0x%02x pps[1]=0x%02x\n",
			FPGA_H264_SPS_PPS.sps_len, FPGA_H264_SPS_PPS.sps[0], FPGA_H264_SPS_PPS.sps[1],
			FPGA_H264_SPS_PPS.pps_len, FPGA_H264_SPS_PPS.pps[0], FPGA_H264_SPS_PPS.pps[1]);
}

void Get_FPGA_H264_SPS_PPS(int *sps_len, char *sps, int *pps_len, char *pps) {
	*sps_len = FPGA_H264_SPS_PPS.sps_len;
	memcpy(sps, &FPGA_H264_SPS_PPS.sps[0], FPGA_H264_SPS_PPS.sps_len);
	*pps_len = FPGA_H264_SPS_PPS.pps_len;
	memcpy(pps, &FPGA_H264_SPS_PPS.pps[0], FPGA_H264_SPS_PPS.pps_len);
}

/*
 * width: width/16
 * height: height/16
 */
void MakeH264DataHeader(unsigned width, unsigned height, char *cT_Buf, unsigned *size, unsigned type) {
    unsigned len=0;
    char HeaderStream[0x100];
    char *cS_Buf;

    cS_Buf = &HeaderStream[0];

    MakeHeader(cS_Buf, (width - 1), (height - 1));

// NAL SPS
    cS_Buf += get_NAL(cS_Buf, cT_Buf, &len, type);
    if(type == 1) {
    	*(cT_Buf + len) = 0x1;
    	len++;
    }

// NAL PPS
    cS_Buf += get_NAL(cS_Buf, cT_Buf, &len, type);
    if(type == 1) {
    	memset(cT_Buf + len, 0, 4);
    	len += 4;
    }

    *size = len;
}

void MakeH264DataHeaderProc() {
	int i, Header_Size;
    int width, height;
	char Header_Buf[64];
    getResolutionWidthHeight(&width, &height);
	MakeH264DataHeader(width/16, height/16, &Header_Buf[0], &Header_Size, 1);
	Set_FPGA_H264_SPS_PPS(&Header_Buf[0]);
}

void SendH264EncodeTable(void) {
	int i;
	unsigned Data[2];
	unsigned *P;
	AS2_CMD_IO_struct table[0x400];
	P = (unsigned*)&table[0];
	unsigned ebittab[0x400] = {
	 0x55,0x77,0x87,0x97,  0xA7,0xCF,0xCB,0xC8,  0xDF,0xDB,0xEF,0xEB,  0xFF,0xFB,0xF7,0xF4,
	 0x11,0x54,0x76,0x86,  0x96,0xA6,0xCE,0xCA,  0xDE,0xDA,0xEE,0xEA,  0xE1,0xFE,0xFA,0xF6,
	 0x00,0x21,0x65,0x75,  0x85,0x95,0xA5,0xCD,  0xC9,0xDD,0xD9,0xED,  0xE9,0xFD,0xF9,0xF5,
	 0x01,0x00,0x43,0x53,  0x64,0x74,0x84,0x94,  0xA4,0xCC,0xDC,0xD8,  0xEC,0xE8,0xFC,0xF8,
	 0x5B,0x57,0x67,0x77,  0x74,0x87,0xAF,0xAB,  0xBF,0xBB,0xB8,0xCF,  0xCB,0xC7,0xD9,0xD7,
	 0x12,0x47,0x5A,0x56,  0x66,0x76,0x86,0xAE,  0xAA,0xBE,0xBA,0xCE,  0xCA,0xDB,0xD8,0xD6,
	 0x00,0x23,0x59,0x55,  0x65,0x75,0x85,0xAD,  0xA9,0xBD,0xB9,0xCD,  0xC9,0xC6,0xDA,0xD5,
	 0x13,0x00,0x35,0x34,  0x46,0x58,0x54,0x64,  0x84,0xAC,0xA8,0xBC,  0xCC,0xC8,0xC1,0xD4,
	 0x5F,0x5B,0x58,0x6F,  0x6B,0x69,0x68,0x7F,  0x7B,0x8F,0x8B,0x88,  0x9D,0x99,0x95,0x91,
	 0x3E,0x4F,0x4C,0x4A,  0x48,0x5E,0x5A,0x6E,  0x7E,0x7A,0x8E,0x8A,  0x87,0x9C,0x98,0x94,
	 0x00,0x3D,0x4E,0x4B,  0x49,0x5D,0x59,0x6D,  0x6A,0x7D,0x79,0x8D,  0x89,0x9B,0x97,0x93,
	 0x3F,0x00,0x3C,0x3B,  0x3A,0x39,0x38,0x4D,  0x5C,0x6C,0x7C,0x78,  0x8C,0x9A,0x96,0x92,
	 0x57,0x54,0x53,0x52,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x01,0x56,0x63,0x73,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x00,0x21,0x62,0x72,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x11,0x00,0x55,0x60,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,

	 0x01,0x27,0x35,0x43,  0x35,0x51,0x51,0x51,  0x51,0x41,0x30,0x30,  0x20,0x10,0x00,0x00,
	 0x23,0x26,0x27,0x27,  0x34,0x41,0x41,0x31,  0x50,0x40,0x31,0x31,  0x21,0x11,0x01,0x00,
	 0x22,0x25,0x26,0x35,  0x33,0x27,0x25,0x41,  0x31,0x21,0x21,0x11,  0x01,0x01,0x00,0x00,
	 0x33,0x24,0x25,0x34,  0x27,0x26,0x24,0x23,  0x13,0x13,0x22,0x01,  0x11,0x00,0x00,0x00,
	 0x32,0x23,0x34,0x26,  0x26,0x25,0x23,0x13,  0x12,0x12,0x01,0x21,  0x00,0x00,0x00,0x00,
	 0x43,0x35,0x33,0x25,  0x25,0x24,0x13,0x12,  0x21,0x11,0x23,0x00,  0x00,0x00,0x00,0x00,
	 0x42,0x34,0x24,0x24,  0x24,0x23,0x22,0x22,  0x11,0x31,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x53,0x33,0x23,0x33,  0x23,0x22,0x31,0x21,  0x41,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x52,0x32,0x32,0x23,  0x32,0x31,0x21,0x50,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x63,0x43,0x43,0x32,  0x41,0x21,0x50,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x62,0x42,0x42,0x42,  0x31,0x50,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x73,0x53,0x51,0x41,  0x40,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x72,0x52,0x41,0x40,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x83,0x51,0x50,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x82,0x50,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x81,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,

	 0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x01,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x01,0x11,0x10,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x13,0x12,0x11,0x10,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x13,0x12,0x11,0x21,  0x20,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x13,0x12,0x23,0x22,  0x21,0x20,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x13,0x20,0x21,0x23,  0x22,0x25,0x24,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x27,0x26,0x25,0x24,  0x23,0x22,0x21,0x31,  0x41,0x51,0x61,0x71,  0x81,0x91,0xA1,0x00,

	 0x00,0x02,0x03,0x07,  0x04,0x08,0x11,0x0D,  0x05,0x12,0x09,0x0E,  0x0A,0x0F,0x10,0x0B,
	 0x01,0x20,0x21,0x24,  0x22,0x25,0x2C,0x28,  0x23,0x2D,0x26,0x29,  0x27,0x2A,0x2B,0x13,
	 0x06,0x18,0x19,0x14,  0x1A,0x15,0x2E,0x1C,  0x1B,0x2F,0x16,0x1D,  0x17,0x1E,0x1F,0x0C,
	 0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x01,0x01,0x01,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x11,0x11,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x21,0x10,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x20,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,

	 0x1a,0x80,0x00,0x00,  0x01,0x01,0x04,0x10,  0x05,0x11,0x02,0x02,  0x03,0x03,0x06,0x12,
	 0x07,0x13,0x08,0x20,  0x09,0x21,0x0c,0x30,  0x0d,0x31,0x0a,0x22,  0x0b,0x23,0x0e,0x32,
	 0x0f,0x33,0x18,0x88,  0x19,0x88,0x10,0x44,  0x11,0x45,0x12,0x54,  0x13,0x55,0x14,0x66,
	 0x15,0x67,0x16,0x76,  0x17,0x77,0x00,0xff,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00
	 };


	 for(i = 0; i < 0x400; i++) {
		table[i].Address = (0xC0000+(i<<2));
		table[i].Data    = ebittab[i];
	 }

	 for(i = 0; i < 32; i++) {
		P = (unsigned *) &table[i*32];
		SPI_Write_IO_S2(0x9, &P[0], sizeof(table)/32 );
	 }
}